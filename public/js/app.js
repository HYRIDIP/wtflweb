class WaterFallApp {
  constructor() {
    this.tg = null;
    this.socket = null;
    this.currentUser = null;
    this.marketData = null;
    this.cryptos = ['MINT', 'RWK', 'SKH', 'WTFL', 'CULT'];
    this.isTelegram = false;
    this.isInitialized = false;
    this.chartManager = null;
    this.api = null;
    
    this.init();
  }
  
  async init() {
    try {
      console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WaterFall App...');
      
      this.initAPI();
      await this.initTelegram();
      
      // –ü–†–û–í–ï–†–ö–ê TELEGRAM - –ë–ï–ó –î–ï–ú–û –†–ï–ñ–ò–ú–ê
      if (!this.isTelegram) {
        this.showTelegramRequired();
        return;
      }
      
      await this.initUser();
      await this.connectToServer();
      this.initCharts();
      this.updateUI();
      
      this.isInitialized = true;
      console.log('‚úÖ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ');
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
      this.showNotification('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è', 'error');
    }
  }
  
  showTelegramRequired() {
    const html = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #070707;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        color: white;
        text-align: center;
        padding: 20px;
      ">
        <div>
          <h1 style="color: #00b15e; margin-bottom: 20px;">WaterFall Trading</h1>
          <p style="font-size: 18px; margin-bottom: 30px;">
            –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Telegram
          </p>
          <div style="
            background: #1e2329;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            margin: 0 auto;
          ">
            <p style="color: #6c757d; margin-bottom: 15px;">
              –û—Ç–∫—Ä–æ–π—Ç–µ —ç—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Telegram –±–æ—Ç–∞ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ç–æ—Ä–≥–æ–≤–ª—é
            </p>
            <p style="color: #f6465d; font-size: 14px;">
              –î–µ–º–æ-—Ä–µ–∂–∏–º –æ—Ç–∫–ª—é—á–µ–Ω. –¢–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ Telegram –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏.
            </p>
          </div>
        </div>
      </div>
    `;
    
    document.body.innerHTML = html;
  }
  
  initAPI() {
    this.api = window.serverAPI || {
      async request(endpoint, data = {}) {
        try {
          const baseUrl = window.location.origin;
          const fullUrl = endpoint.startsWith('/') ? `${baseUrl}${endpoint}` : endpoint;
          
          const response = await fetch(fullUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          return result;
        } catch (error) {
          console.error(`API Error (${endpoint}):`, error);
          throw new Error(`–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
        }
      },
      
      async createOrder(orderData) {
        return this.request('/api/order/create', orderData);
      },
      
      async createDeposit(depositData) {
        return this.request('/api/deposit/create', depositData);
      },
      
      async createWithdrawal(withdrawalData) {
        return this.request('/api/withdraw', withdrawalData);
      }
    };
    console.log('üîå API –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
  }
  
  async initTelegram() {
    if (window.Telegram && window.Telegram.WebApp) {
      this.tg = window.Telegram.WebApp;
      this.isTelegram = true;
      
      this.tg.ready();
      this.tg.expand();
      this.tg.enableClosingConfirmation();
      this.tg.setHeaderColor('#1e2329');
      this.tg.setBackgroundColor('#070707');
      
      console.log('üì± Telegram Web App –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    } else {
      console.log('‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è Telegram Web App');
      this.isTelegram = false;
    }
  }
  
  async initUser() {
    // –ù–ï–¢ LOCALSTORAGE - –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –∏–∑ –±–∞–∑—ã
    console.log('üë§ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö...');
    
    if (!this.isTelegram || !this.tg?.initDataUnsafe?.user) {
      throw new Error('Telegram user data not available');
    }
    
    // –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    console.log('‚è≥ –û–∂–∏–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞...');
  }
  
  async connectToServer() {
    try {
      if (!this.isTelegram || !this.tg?.initDataUnsafe?.user) {
        throw new Error('Telegram user data required');
      }
      
      console.log('üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...');
      
      const telegramUser = this.tg.initDataUnsafe.user;
      const socketUrl = window.location.origin;
      
      this.socket = io(socketUrl, {
        transports: ['websocket', 'polling'],
        timeout: 10000,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000
      });
      
      this.setupSocketHandlers();
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ Telegram –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const userDataToSend = {
        id: telegramUser.id.toString(),
        username: telegramUser.username,
        firstName: telegramUser.first_name,
        lastName: telegramUser.last_name,
        photoUrl: telegramUser.photo_url,
        isTelegramUser: true,
        telegramData: telegramUser
      };
      
      if (this.socket.connected) {
        this.socket.emit('join', userDataToSend);
      } else {
        this.socket.once('connect', () => {
          this.socket.emit('join', userDataToSend);
        });
      }
      
      console.log('‚úÖ –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');
      
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É:', error);
      this.showNotification('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É', 'error');
      throw error;
    }
  }
  
  setupSocketHandlers() {
    this.socket.on('userData', (serverUserData) => {
      console.log('üì® –ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞:', serverUserData);
      
      this.currentUser = serverUserData;
      this.updateUI();
    });
    
    this.socket.on('marketData', (data) => {
      console.log('üìà –ü–æ–ª—É—á–µ–Ω—ã —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:', data);
      this.marketData = data;
      
      this.updateCharts();
      this.updatePrices();
      this.updateHoldings();
    });
    
    this.socket.on('marketUpdate', (data) => {
      if (this.marketData && data.crypto) {
        this.marketData.prices[data.crypto] = data.price;
        
        if (data.history && this.marketData.history) {
          this.marketData.history[data.crypto] = data.history;
        }
        
        this.updatePrices();
        this.updateHoldings();
        this.updateCharts();
      }
    });
    
    this.socket.on('orderExecuted', (data) => {
      this.showNotification(
        `‚úÖ –û—Ä–¥–µ—Ä –∏—Å–ø–æ–ª–Ω–µ–Ω: ${data.type === 'buy' ? '–ü–û–ö–£–ü–ö–ê' : '–ü–†–û–î–ê–ñ–ê'} ${data.amount} ${data.crypto} –ø–æ $${data.price.toFixed(4)}`,
        'success'
      );
      
      if (this.currentUser) {
        if (data.type === 'buy') {
          this.currentUser.balance -= data.amount * data.price;
          this.currentUser.crypto[data.crypto] = (this.currentUser.crypto[data.crypto] || 0) + data.amount;
        } else {
          this.currentUser.balance += data.amount * data.price;
          this.currentUser.crypto[data.crypto] = (this.currentUser.crypto[data.crypto] || 0) - data.amount;
        }
        
        this.currentUser.trades = this.currentUser.trades || [];
        this.currentUser.trades.push({
          id: Date.now().toString(),
          crypto: data.crypto,
          type: data.type,
          amount: data.amount,
          price: data.price,
          total: data.amount * data.price,
          timestamp: Date.now()
        });
        
        this.updateUI();
      }
    });
    
    this.socket.on('depositSuccess', (data) => {
      this.showNotification(
        `üí∞ –î–µ–ø–æ–∑–∏—Ç —É—Å–ø–µ—à–µ–Ω! $${data.amount} –∑–∞—á–∏—Å–ª–µ–Ω –Ω–∞ –±–∞–ª–∞–Ω—Å`,
        'success'
      );
      
      if (this.currentUser) {
        this.currentUser.balance = data.newBalance;
        this.currentUser.totalInvested += data.amount;
        this.updateUI();
      }
    });
    
    this.socket.on('withdrawalSuccess', (data) => {
      this.showNotification(
        `üí∏ –í—ã–≤–æ–¥ —É—Å–ø–µ—à–µ–Ω! $${data.netAmount} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à –∫–æ—à–µ–ª–µ–∫ (–∫–æ–º–∏—Å—Å–∏—è: $${data.fee})`,
        'success'
      );
      
      if (this.currentUser) {
        this.currentUser.balance = data.newBalance;
        this.updateUI();
      }
    });
    
    this.socket.on('error', (error) => {
      console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:', error);
      this.showNotification(`–û—à–∏–±–∫–∞: ${error.message}`, 'error');
    });
    
    this.socket.on('connect', () => {
      console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
    });
    
    this.socket.on('disconnect', (reason) => {
      console.log('üîå –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:', reason);
      if (reason === 'io server disconnect') {
        this.showNotification('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ', 'warning');
      }
    });
    
    this.socket.on('reconnect', () => {
      console.log('üîÅ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É');
      this.showNotification('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'success');
    });
  }
  
  initCharts() {
    if (window.ChartManager) {
      this.chartManager = new window.ChartManager();
      window.chartManager = this.chartManager;
      console.log('üìà ChartManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    } else {
      console.log('‚ö†Ô∏è ChartManager –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback');
    }
  }
  
  updateUI() {
    if (!this.currentUser) {
      console.log('‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI');
      return;
    }
    
    console.log('üé® –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞...', this.currentUser);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É
    const avatarEl = document.getElementById('userAvatar');
    if (avatarEl && this.currentUser.photoUrl) {
      avatarEl.src = this.currentUser.photoUrl;
      avatarEl.onerror = () => {
        avatarEl.src = '/assets/homepage/unsplash-p-at-a8xe.png';
      };
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const nameEl = document.getElementById('userName');
    if (nameEl) {
      const displayName = this.currentUser.firstName || this.currentUser.username || '–¢—Ä–µ–π–¥–µ—Ä';
      nameEl.textContent = this.currentUser.firstLogin ? 
        `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, ${displayName}!` : 
        `–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, ${displayName}!`;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å
    this.updateBalance();
    this.updateHoldings();
    this.updateTradeHistory();
  }
  
  updateBalance() {
    if (!this.currentUser) return;
    
    const balance = this.currentUser.balance || 0;
    
    const balanceSelectors = [
      '#userBalance',
      '#availableBalance', 
      '#currentBalance',
      '#usdBalance',
      '.balance-amount',
      '.card-subtitle'
    ];
    
    balanceSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(element => {
        if (element.textContent.includes('$') || element.classList.contains('balance-amount') || 
            element.id.includes('Balance')) {
          element.textContent = `$${balance.toFixed(2)}`;
        }
      });
    });
  }
  
  updateHoldings() {
    if (!this.currentUser || !this.marketData) return;
    
    this.cryptos.forEach(crypto => {
      const amount = this.currentUser.crypto?.[crypto] || 0;
      const price = this.marketData.prices?.[crypto] || 0;
      const value = amount * price;
      const change = this.getPriceChange(crypto);
      
      const container = document.getElementById(`holding-${crypto}`);
      if (container) {
        container.innerHTML = `
          <p class="text-gray2">${amount.toFixed(2)} ${crypto}</p>
          <p class="text-white1">$${value.toFixed(2)}</p>
          ${change !== 0 ? `
            <p class="${change > 0 ? 'text-profit' : 'text-loss'}">
              ${change > 0 ? '‚Üó' : '‚Üò'} ${Math.abs(change).toFixed(1)}%
            </p>
          ` : ''}
        `;
      }
      
      const cryptoBalanceEl = document.getElementById('cryptoBalance');
      if (cryptoBalanceEl && window.location.pathname.includes('trading-')) {
        cryptoBalanceEl.textContent = amount.toFixed(4);
      }
      
      const priceElement = document.getElementById(`price-${crypto}`);
      if (priceElement) {
        priceElement.innerHTML = `
          $${price.toFixed(4)}
          ${change !== 0 ? `
            <span class="${change > 0 ? 'price-up' : 'price-down'}">
              ${change > 0 ? '‚Üó' : '‚Üò'} ${Math.abs(change).toFixed(1)}%
            </span>
          ` : ''}
        `;
      }
    });
  }
  
  updateTradeHistory() {
    if (!this.currentUser?.trades || !Array.isArray(this.currentUser.trades)) return;
    
    const historyContainer = document.getElementById('tradeHistory');
    if (!historyContainer) return;
    
    const recentTrades = this.currentUser.trades.slice(-10).reverse();
    
    if (recentTrades.length === 0) {
      historyContainer.innerHTML = '<div class="text-center text-gray2 py-4">–ù–µ—Ç —Å–¥–µ–ª–æ–∫</div>';
      return;
    }
    
    historyContainer.innerHTML = recentTrades.map(trade => `
      <div class="trade-item ${trade.type}">
        <div class="trade-info">
          <span class="trade-type ${trade.type}">${trade.type === 'buy' ? '–ü–û–ö–£–ü–ö–ê' : '–ü–†–û–î–ê–ñ–ê'}</span>
          <span class="trade-crypto">${trade.crypto}</span>
        </div>
        <div class="trade-details">
          <span class="trade-amount">${trade.amount} ${trade.crypto}</span>
          <span class="trade-price">$${trade.price.toFixed(4)}</span>
          <span class="trade-total">$${trade.total.toFixed(2)}</span>
        </div>
        <div class="trade-time">${new Date(trade.timestamp).toLocaleTimeString()}</div>
      </div>
    `).join('');
  }
  
  updateCharts() {
    if (!this.marketData) {
      console.log('‚ùå –ù–µ—Ç —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤');
      return;
    }
    
    console.log('üìä –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤ —Å –¥–∞–Ω–Ω—ã–º–∏:', this.marketData);
    
    if (this.chartManager && this.chartManager.updateAllCharts) {
      console.log('‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º ChartManager –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–æ–≤');
      this.chartManager.updateAllCharts(this.marketData);
    } 
    else if (window.initAllMiniCharts) {
      console.log('‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º initAllMiniCharts –¥–ª—è –º–∏–Ω–∏-–≥—Ä–∞—Ñ–∏–∫–æ–≤');
      window.initAllMiniCharts(this.marketData);
    }
    else {
      console.log('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º fallback –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤');
      this.drawBasicCharts();
    }
  }
  
  drawBasicCharts() {
    this.cryptos.forEach(crypto => {
      const history = this.marketData.history?.[crypto];
      const canvasId = `chart-${crypto}`;
      
      if (history && history.length > 0) {
        this.drawMiniChart(canvasId, history.slice(-20));
      }
    });
  }
  
  drawMiniChart(canvasId, data) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!data || data.length < 2) return;
    
    try {
      const prices = data.map(d => d.price);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const range = maxPrice - minPrice || 1;
      
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      
      const isPositive = prices[prices.length - 1] > prices[0];
      ctx.strokeStyle = isPositive ? '#00b15e' : '#f6465d';
      
      data.forEach((point, index) => {
        const x = (index / (data.length - 1)) * width;
        const y = height - ((point.price - minPrice) / range) * height;
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
    } catch (error) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ ${canvasId}:`, error);
    }
  }
  
  updatePrices() {
    if (!this.marketData) return;
    
    this.cryptos.forEach(crypto => {
      const priceElement = document.getElementById(`price-${crypto}`);
      if (priceElement) {
        const price = this.marketData.prices?.[crypto] || 0;
        const change = this.getPriceChange(crypto);
        
        priceElement.innerHTML = `
          $${price.toFixed(4)}
          ${change !== 0 ? `
            <span class="${change > 0 ? 'price-up' : 'price-down'}">
              ${change > 0 ? '‚Üó' : '‚Üò'} ${Math.abs(change).toFixed(1)}%
            </span>
          ` : ''}
        `;
      }
    });
  }
  
  getPriceChange(crypto) {
    if (!this.marketData?.history?.[crypto] || this.marketData.history[crypto].length < 2) {
      return 0;
    }
    
    const history = this.marketData.history[crypto];
    const current = history[history.length - 1].price;
    const previous = history[Math.max(0, history.length - 10)].price;
    
    return ((current - previous) / previous) * 100;
  }
  
  // –ù–∞–≤–∏–≥–∞—Ü–∏—è
  showTradingPage(crypto) {
    const cryptoPages = {
      'MINT': 'trading-MINT.html',
      'RWK': 'trading-RWK.html', 
      'SKH': 'trading-SKH.html',
      'WTFL': 'trading-WTFL.html',
      'CULT': 'trading-CULT.html'
    };
    
    const page = cryptoPages[crypto];
    if (page) {
      window.location.href = page;
    } else {
      this.showNotification('–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error');
    }
  }
  
  showDeposit() {
    window.location.href = 'deposit.html';
  }
  
  showWithdraw() {
    window.location.href = 'withdraw.html';
  }
  
  showWallet() {
    window.location.href = 'wallet.html';
  }
  
  showHome() {
    window.location.href = 'index.html';
  }
  
  // –î–µ–ø–æ–∑–∏—Ç —Å –≤—ã–±–æ—Ä–æ–º –º–µ—Ç–æ–¥–∞
  async createDeposit(amount, method = 'CRYPTOPAY', asset = 'USDT') {
    try {
      if (!this.currentUser) {
        this.showNotification('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω', 'error');
        return null;
      }
      
      const result = await this.api.createDeposit({
        amount: parseFloat(amount),
        userId: this.currentUser.id,
        method: method,
        asset: asset
      });
      
      if (result.success) {
        if (method === 'CRYPTOPAY') {
          if (this.tg && this.tg.openInvoice) {
            this.tg.openInvoice(result.invoiceUrl, (status) => {
              console.log('CryptoPay invoice status:', status);
              if (status === 'paid') {
                this.showNotification('–î–µ–ø–æ–∑–∏—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∏—Å–ª–µ–Ω!', 'success');
              } else if (status === 'failed' || status === 'cancelled') {
                this.showNotification('–û–ø–ª–∞—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ –∏–ª–∏ –Ω–µ —É–¥–∞–ª–∞—Å—å', 'error');
              }
            });
          } else {
            window.open(result.invoiceUrl, '_blank', 'width=400,height=600');
            this.showNotification('–û—Ç–∫—Ä–æ–π—Ç–µ —Å—Å—ã–ª–∫—É –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã', 'info');
          }
        } else {
          this.showPaymentAddress(method, result.address, amount);
        }
        
        return result;
      } else {
        this.showNotification(`‚ùå ${result.error}`, 'error');
        return null;
      }
    } catch (error) {
      this.showNotification(`‚ùå ${error.message}`, 'error');
      return null;
    }
  }
  
  showPaymentAddress(method, address, amount) {
    const methodNames = {
      'TRC20': 'USDT (TRC20)',
      'TON': 'TON'
    };
    
    const message = `
üí∞ –î–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–∞ $${amount}:

–ú–µ—Ç–æ–¥: ${methodNames[method] || method}
–ê–¥—Ä–µ—Å: ${address}

–ü–æ—Å–ª–µ –ø–µ—Ä–µ–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤–∞ –ø–æ—Å—Ç—É–ø—è—Ç –≤ —Ç–µ—á–µ–Ω–∏–µ 10-15 –º–∏–Ω—É—Ç.
    `;
    
    this.showNotification(message, 'info');
    this.showPaymentModal(method, address, amount);
  }
  
  showPaymentModal(method, address, amount) {
    const methodNames = {
      'TRC20': 'USDT (TRC20 Network)',
      'TON': 'TON (TON Network)'
    };
    
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;
    
    modal.innerHTML = `
      <div style="
        background: #1e2329;
        padding: 20px;
        border-radius: 12px;
        max-width: 400px;
        width: 90%;
        text-align: center;
      ">
        <h3 style="color: white; margin-bottom: 15px;">–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ $${amount}</h3>
        <p style="color: #6c757d; margin-bottom: 15px;">${methodNames[method] || method}</p>
        <div style="
          background: white;
          padding: 10px;
          border-radius: 8px;
          margin-bottom: 15px;
          word-break: break-all;
          font-family: monospace;
          font-size: 12px;
          color: black;
        ">
          ${address}
        </div>
        <button id="copyAddressBtn" style="
          background: #00b15e;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 6px;
          cursor: pointer;
          margin-right: 10px;
        ">
          –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∞–¥—Ä–µ—Å
        </button>
        <button id="closeModalBtn" style="
          background: #6c757d;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 6px;
          cursor: pointer;
        ">
          –ó–∞–∫—Ä—ã—Ç—å
        </button>
        <p style="color: #6c757d; margin-top: 15px; font-size: 12px;">
          –°—Ä–µ–¥—Å—Ç–≤–∞ –ø–æ—Å—Ç—É–ø—è—Ç –ø–æ—Å–ª–µ 1 –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–µ—Ç–∏
        </p>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    modal.querySelector('#copyAddressBtn').addEventListener('click', () => {
      navigator.clipboard.writeText(address).then(() => {
        this.showNotification('–ê–¥—Ä–µ—Å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
      });
    });
    
    modal.querySelector('#closeModalBtn').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
  }
  
  // –í—ã–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤
  async createWithdrawal(amount, address, method = 'TRC20', asset = 'USDT') {
    try {
      if (!this.currentUser) {
        this.showNotification('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω', 'error');
        return null;
      }
      
      const result = await this.api.createWithdrawal({
        amount: parseFloat(amount),
        address: address,
        method: method,
        asset: asset,
        userId: this.currentUser.id
      });
      
      if (result.success) {
        this.showNotification(`‚úÖ –í—ã–≤–æ–¥ $${result.netAmount} —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω!`, 'success');
        return result;
      } else {
        this.showNotification(`‚ùå ${result.error}`, 'error');
        return null;
      }
    } catch (error) {
      this.showNotification(`‚ùå ${error.message}`, 'error');
      return null;
    }
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞
  async createOrder(crypto, type, price, amount) {
    try {
      if (!this.currentUser) {
        this.showNotification('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω', 'error');
        return false;
      }
      
      const result = await this.api.createOrder({
        crypto: crypto,
        type: type,
        price: parseFloat(price),
        amount: parseFloat(amount),
        userId: this.currentUser.id
      });
      
      if (result.success) {
        this.showNotification('‚úÖ –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!', 'success');
        return true;
      } else {
        this.showNotification(`‚ùå ${result.error}`, 'error');
        return false;
      }
    } catch (error) {
      this.showNotification(`‚ùå ${error.message}`, 'error');
      return false;
    }
  }
  
  // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  showNotification(message, type = 'info') {
    console.log(`üì¢ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ [${type}]:`, message);
    
    if (this.tg && this.tg.showPopup) {
      if (type === 'error') {
        this.tg.showPopup({
          title: '–û—à–∏–±–∫–∞',
          message: message,
          buttons: [{ type: 'ok' }]
        });
      } else {
        this.tg.showAlert(message);
      }
    } else {
      this.showBrowserNotification(message, type);
    }
  }
  
  showBrowserNotification(message, type = 'info') {
    let container = document.getElementById('notification-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'notification-container';
      container.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        max-width: 400px;
      `;
      document.body.appendChild(container);
    }
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.style.cssText = `
      background: #1e2329;
      border-left: 4px solid ${type === 'error' ? '#f6465d' : type === 'warning' ? '#f0b90b' : '#00b15e'};
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 10px;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideInRight 0.3s ease-out;
      max-width: 400px;
      word-wrap: break-word;
    `;
    
    notification.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>${message}</span>
        <button onclick="this.parentElement.parentElement.remove()" style="
          background: none;
          border: none;
          color: white;
          font-size: 18px;
          cursor: pointer;
          padding: 0;
          width: 24px;
          height: 24px;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-left: 10px;
        ">√ó</button>
      </div>
    `;
    
    container.appendChild(notification);
    
    setTimeout(() => {
      if (notification.parentElement) {
        notification.style.animation = 'slideOutRight 0.3s ease-in';
        setTimeout(() => notification.remove(), 300);
      }
    }, 5000);
  }
  
  destroy() {
    if (this.socket) {
      this.socket.disconnect();
    }
    if (this.chartManager) {
      this.chartManager.destroyAll();
    }
  }
}

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
let app;

document.addEventListener('DOMContentLoaded', () => {
  console.log('üìÑ DOM –∑–∞–≥—Ä—É–∂–µ–Ω, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
  
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
  `;
  document.head.appendChild(style);
  
  app = new WaterFallApp();
});

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è HTML
function startTrading(crypto) {
  if (window.app && window.app.showTradingPage) {
    window.app.showTradingPage(crypto);
  } else {
    const pages = {
      'MINT': 'trading-MINT.html',
      'RWK': 'trading-RWK.html',
      'SKH': 'trading-SKH.html', 
      'WTFL': 'trading-WTFL.html',
      'CULT': 'trading-CULT.html'
    };
    window.location.href = pages[crypto] || 'wallet.html';
  }
}

function goToDeposit() {
  if (window.app && window.app.showDeposit) {
    window.app.showDeposit();
  } else {
    window.location.href = 'deposit.html';
  }
}

function goToWithdraw() {
  if (window.app && window.app.showWithdraw) {
    window.app.showWithdraw();
  } else {
    window.location.href = 'withdraw.html';
  }
}

function goToWallet() {
  if (window.app && window.app.showWallet) {
    window.app.showWallet();
  } else {
    window.location.href = 'wallet.html';
  }
}

function goToHome() {
  if (window.app && window.app.showHome) {
    window.app.showHome();
  } else {
    window.location.href = 'index.html';
  }
}

// –¢–æ—Ä–≥–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
function placeBuyOrder() {
  if (!window.app) return;
  
  const crypto = getCurrentCrypto();
  const priceInput = document.getElementById('buyPrice');
  const amountInput = document.getElementById('buyAmount');
  
  if (!priceInput || !amountInput) return;
  
  const price = parseFloat(priceInput.value);
  const amount = parseFloat(amountInput.value);
  
  if (!price || !amount) {
    window.app.showNotification('–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', 'error');
    return;
  }
  
  window.app.createOrder(crypto, 'buy', price, amount);
}

function placeSellOrder() {
  if (!window.app) return;
  
  const crypto = getCurrentCrypto();
  const priceInput = document.getElementById('sellPrice');
  const amountInput = document.getElementById('sellAmount');
  
  if (!priceInput || !amountInput) return;
  
  const price = parseFloat(priceInput.value);
  const amount = parseFloat(amountInput.value);
  
  if (!price || !amount) {
    window.app.showNotification('–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', 'error');
    return;
  }
  
  window.app.createOrder(crypto, 'sell', price, amount);
}

function getCurrentCrypto() {
  const path = window.location.pathname;
  if (path.includes('trading-')) {
    return path.split('trading-')[1].replace('.html', '').toUpperCase();
  }
  return 'MINT';
}

window.addEventListener('beforeunload', () => {
  if (window.app) {
    window.app.destroy();
  }
});
